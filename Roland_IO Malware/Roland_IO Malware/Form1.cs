namespace Roland_IO_Malware
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Security.Cryptography;
    using System.Threading;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Management;
    using System.ServiceProcess;
    using System.Drawing;
    using System.Linq;
    using System.Runtime;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;
    using static System.String;
    using Timer = System.Threading.Timer;

    public partial class Form1 : Form
    {
        //private readonly FormWindowState mLastState;

        private readonly BackgroundWorker _scanWindowsServices = null;

        private BackgroundWorker _folderWatcher = null;

        private BackgroundWorker _processWatcher = null;

        private Scanner scannerForCashing;

        /// <summary>
        /// The set text callback.
        /// </summary>
        /// <param name="text">
        /// The text.
        /// </param>
        public delegate void SetTextCallback(string text);

        public delegate void SetTextCallinteger(int value);

        public delegate void SetCallback();

        public delegate void SetScrollToCaret();

        /// <summary>
        /// The _reset event.
        /// </summary>
        //private readonly AutoResetEvent resetEvent = new AutoResetEvent(false);

        /// <summary>
        /// The object used for cancelling tasks.
        /// </summary>
        private CancellationTokenSource m_CancelTokenSource = null;

        ///// <summary>
        ///// The list of created tasks.
        ///// </summary>
        //private List<Task> m_TaskList = null;

        /// <summary>
        /// The set text.
        /// </summary>
        /// <param name="text">
        /// The text.
        /// </param>
        public void SetEventLogText(string text)
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetTextCallback d = SetEventLogText;
                this.Invoke(d, text);
            }
            else
            {
                this.eventlogmessage.Text = text;
            }
        }


        public void ProgressIncrement()
        {
            if (this.progressBar1.InvokeRequired)
            {
                SetCallback d = ProgressIncrement;
                this.Invoke(d);
            }
            else
            {
                this.progressBar1.PerformStep();
            }
        }

        public void ProgressStyleContinious()
        {
            MethodInvoker mi = new MethodInvoker(() => progressBar1.Style = ProgressBarStyle.Continuous);
            if (progressBar1.InvokeRequired)
            {
                progressBar1.Invoke(mi);
            }
            else
            {
                mi.Invoke();
            }
        }


        public void ProgreeMinimum()
        {
            if (this.progressBar1.InvokeRequired)
            {
                SetCallback d = ProgreeMinimum;
                this.Invoke(d);
            }
            else
            {
                this.progressBar1.Value = progressBar1.Minimum;
            }
        }


        public void ProgreeStyleMarquee()
        {
            MethodInvoker mi = new MethodInvoker(() => progressBar1.Style = ProgressBarStyle.Marquee);
            if (progressBar1.InvokeRequired)
            {
                progressBar1.Invoke(mi);
            }
            else
            {
                mi.Invoke();
            }
        }


        public void ProgressSpeed(int value)
        {
            MethodInvoker mi = new MethodInvoker(() => progressBar1.MarqueeAnimationSpeed = value);
            if (progressBar1.InvokeRequired)
            {
                progressBar1.Invoke(mi);
            }
            else
            {
                mi.Invoke();
            }
        }


        public int ProgresMaximum()
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetTextCallback d = SetEventLogText;
                this.Invoke(d);
                return 0;
            }
            else
            {
                return progressBar1.Maximum;
            }
        }

        public void ProgresValue(int value)
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetTextCallinteger d = ProgresValue;
                this.Invoke(d, value);
            }
            else
            {
                progressBar1.Value = value;
            }
        }

        public void ProcessText(string text)
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetTextCallback d = ProcessText;
                this.Invoke(d, text);
            }
            else
            {
                this.textBox3.Text = text;
            }
        }


        public void RichTextBox(string text)
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetTextCallback d = this.RichTextBox;
                this.Invoke(d, text);
            }
            else
            {
                this.richTextBox1.Text += text;
            }
        }

        public void RichTextBoxScroll()
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetScrollToCaret d = RichTextBoxScroll;
                this.Invoke(d);
            }
            else
            {
                this.richTextBox1.SelectionStart = this.richTextBox1.Text.Length;
                this.richTextBox1.ScrollToCaret();
            }
        }

        public void SetNotificationText(string text)
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            if (this.eventlogmessage.InvokeRequired)
            {
                SetTextCallback d = this.SetNotificationText;
                this.Invoke(d, text);
            }
            else
            {
                textBox2.Text += text;
            }
        }

        ///// <summary>
        ///// The cancel.
        ///// </summary>
        //public void Cancel()
        //{
        //    this.LocalMachine.CancelAsync();
        //    resetEvent.WaitOne();
        //}

        public Form1()
        {

            scannerForCashing = new Scanner();

            //Registry.CurrentUser.DeleteSubKey("Roland IO");
            if (Registry.CurrentUser.OpenSubKey("Roland IO") == null)
            {
                if (!ServiceInstaller.ServiceIsInstalled("Malware Detection Scanner"))
                {
                    ServiceInstaller.InstallAndStart("Malware Detection Scanner", "Malware Detection Scanner", @"C:\PathToServiceFile.exe");
                }
                RegistryKey key;
                key = Registry.CurrentUser.CreateSubKey("Roland IO");
                if (key != null)
                {
                    key.SetValue("FirstStartup", "true");
                    key.Close();
                }

                // TODO: create first startup registry
                Form form2 = new Form();
                form2.Visible = true;
                form2.IsMdiContainer = true;
                TextBox myText = new TextBox();
                myText.Location = new Point(25, 25);
                myText.Text = "Scanning for first time usage. Please wait...";
                form2.Controls.Add(myText);
                this.Visible = false;
                BuildStartup(false);
                Scanning(false);
                form2.Visible = false;
                this.Visible = true;

                // Save the values as cash to file
                scannerForCashing.SaveCashedValues();

                // Clear cash to ensure that bew values are writte to file
                scannerForCashing.ClearMd5Values();
            }

            InitializeComponent();
            StartBackgroundWork();
            GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
            scannerForCashing.LoadCashedValues();

            //this._ProcessWatcher = new BackgroundWorker();
            //InitializeEventScannerProcessWatcher();
            //this._ProcessWatcher.RunWorkerAsync();

            //WaitForProcess();

            //this._scanWindowsServices = new BackgroundWorker();
            //InitializeEventScannerWindowsServices();
            //_scanWindowsServices.RunWorkerAsync();

            this._folderWatcher = new BackgroundWorker();
            InitializeEventScannerFolderWatcher();
            this._folderWatcher.RunWorkerAsync();

            // Initialize systemt tray menu
            SysTrayApp();


            // This will later on be expanded to check a server for updates
            var updater = new Updater();
            if (updater.IsThereAnUpdate())
            {
                updater.UpdateDatabase();
            }

            notifyIcon1.DoubleClick += (sender, e) =>
            {
                var thisIcon = (NotifyIcon)sender;
                thisIcon.Visible = false;
            };

            notifyIcon1.MouseClick += (sender, e) =>
            {
                var thisIcon = (NotifyIcon)sender;
            };

            this.notifyIcon1.Icon = Icon.ExtractAssociatedIcon(Thread.GetDomain().BaseDirectory + "Malware.ico");

            var frmMainResize = new BackgroundWorker();
            frmMainResize.WorkerReportsProgress = true;
            frmMainResize.WorkerSupportsCancellation = true;
            frmMainResize.DoWork += this.FrmMainResize;
            frmMainResize.RunWorkerAsync();
        }


        public void SysTrayApp()
        {
            // Create a simple tray menu with only one item.
            var trayMenu = new ContextMenu();
            trayMenu.MenuItems.Add("Exit", OnExit);
            trayMenu.MenuItems.Add("Show", OnShow);

            // Create a tray icon. 
            notifyIcon1.Text = "Roland IO";
            // Add menu to tray icon
            notifyIcon1.ContextMenu = trayMenu;
        }

        public Form Form2;

        private void OnExit(object sender, EventArgs e)
        {
            scannerForCashing.SaveCashedValues();
            Form2 = new Form();
            Form2.Visible = true;
            Form2.IsMdiContainer = true;
            TextBox myText = new TextBox();
            myText.Location = new Point(10, 10);
            myText.Width = 250;
            myText.Text = "If you close this application, you computer my be in danger";

            Button yes = new Button();
            yes.Text = "Close";
            yes.Click += AcceptApplicationClose;
            yes.Location = new Point(10, 50);

            Button no = new Button();
            no.Text = "Continue realtime scanning";
            no.Click += CountinueRealTimeScanning;
            no.Location = new Point(10, 100);


            Form2.MinimizeBox = false;
            Form2.MaximizeBox = false;
            Form2.Closing += ChancelClose;

            Form2.Controls.Add(myText);
            Form2.Controls.Add(yes);
            Form2.Controls.Add(no);
            Form2.Visible = true;

        }

        private void ChancelClose(object sender, CancelEventArgs e)
        {
            e.Cancel = true;
        }

        private void AcceptApplicationClose(object sender, EventArgs e)
        {
            notifyIcon1.Dispose();
            Application.Exit();
        }


        private void CountinueRealTimeScanning(object sender, EventArgs e)
        {
            this.Visible = false;
            Form2.Visible = false;
            Form2 = null;
        }



        private void OnShow(object sender, EventArgs e)
        {
            if (FormWindowState.Minimized == this.WindowState)
            {
                notifyIcon1.Visible = false;
                this.ShowInTaskbar = true;
                this.Activate();
                this.Visible = true;
                this.Show();
            }
            if (FormWindowState.Normal == this.WindowState)
            {
                notifyIcon1.Visible = false;
                this.ShowInTaskbar = true;
                this.Activate();
                this.Visible = true;
                this.Show();
            }
        }

        /// <summary>
        /// The initialize worker processes.
        /// </summary>
        //private void InitializeEventScannerProcessWatcher()
        //{
        //    this._ProcessWatcher.WorkerReportsProgress = true;
        //    this._ProcessWatcher.WorkerSupportsCancellation = true;
        //    this._ProcessWatcher.DoWork += this.WaitForProcess;
        //}

        /// <summary>
        /// The initialize worker processes.
        /// </summary>
        private void InitializeEventScannerFolderWatcher()
        {
            this._folderWatcher.WorkerReportsProgress = true;
            this._folderWatcher.WorkerSupportsCancellation = true;
            this._folderWatcher.DoWork += this.FolderWatcher;
        }

        /// <summary>
        /// The initialize worker processes.
        /// </summary>
        //private void InitializeEventScannerWindowsServices()
        //{
        //    this._scanWindowsServices.WorkerReportsProgress = true;
        //    this._scanWindowsServices.WorkerSupportsCancellation = true;
        //    this._scanWindowsServices.DoWork += Monitor;
        //}



        public void WatchForAppEvent(EventLog log)
        {
            log.EntryWritten += this.OnEntryWritten;
        }

        public void OnEntryWritten(object source, EntryWrittenEventArgs entryArg)
        {
            SetEventLogText(entryArg.Entry.Message);
            // Program installation or Windows Service installation
            if (entryArg.Entry.InstanceId == 20001 || entryArg.Entry.InstanceId == 20003)
            {
                SetEventLogText(entryArg.Entry.Message);
            }
        }

        /// <summary>
        /// The _reset event.
        /// </summary>
        // ReSharper disable once InconsistentNaming
        //private readonly AutoResetEvent _resetEvent = new AutoResetEvent(false);


        //public void CancelProcessScanning()
        //{
        //    this.LocalMachine.CancelAsync();
        //    _resetEvent.WaitOne();
        //}


        private void Button1Click(object sender, EventArgs e)
        {
            m_CancelTokenSource = new CancellationTokenSource();
            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = m_CancelTokenSource.Token;
            DialogResult result = openFileDialog1.ShowDialog();
            openFileDialog1.Multiselect = false;
            var task = Task.Factory.StartNew(() =>
            {
                // If cancel has been chosen, throw an exception now before doing anything.
                readFileCancelToken.ThrowIfCancellationRequested();
                try
                {
                    if (result == DialogResult.OK)
                    {
                        string file = openFileDialog1.FileName;
                        try
                        {
                            using (var md5 = MD5.Create())
                            {
                                using (var stream = File.OpenRead(openFileDialog1.FileName))
                                {
                                    var md5Byte = md5.ComputeHash(stream);
                                    string md5String = BitConverter.ToString(md5Byte).Replace("-", "");

                                    stream.Close();
                                    var scanResult = scannerForCashing.ScanFile(md5String.ToLower() + "$", 4);
                                    if (scanResult)
                                    {
                                        SetNotificationText(Path.GetFileName(file) + " ---- is a virus -- Quarantined");
                                        var fileName = Path.GetFileNameWithoutExtension(file);
                                        var path = file.Replace(Path.GetFileName(file), string.Empty);
                                        var process =
                                            Process.GetProcessesByName(fileName)
                                                .FirstOrDefault(p => p.MainModule.FileName.StartsWith(path));
                                        var lockedProcesses = FileUtil.WhoIsLocking(file).ToList();
                                        foreach (var lockedProcess in lockedProcesses)
                                        {
                                            lockedProcess.Kill();
                                        }
                                        process?.Kill();
                                        File.SetAttributes(file, FileAttributes.Normal);
                                        var databaseDirectory = Thread.GetDomain().BaseDirectory + "Quarantine\\";
                                        if (File.Exists(databaseDirectory + fileName + "." + md5String))
                                            File.Delete(databaseDirectory + fileName + "." + md5String);
                                        File.Move(file, databaseDirectory + fileName + "." + md5String);
                                    }
                                }
                            }
                        }
                        catch (IOException ex)
                        {
                            RichTextBox(ex.Message);
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                    //
                }
                catch (Exception ex)
                {
                    RichTextBox(ex.Message);
                }
                finally
                {
                    GC.Collect();
                }
            }, readFileCancelToken);
        }

        public string GetProcessPath(string name)
        {
            Process[] processes = Process.GetProcessesByName(name);

            if (processes.Length > 0)
            {
                return processes[0].MainModule.FileName;
            }
            else
            {
                return string.Empty;
            }
        }

        private void Button2Click(object sender, EventArgs e)
        {
            DialogResult result = folderBrowserDialog1.ShowDialog();
            if (result == DialogResult.OK)
            {
                string folder = folderBrowserDialog1.SelectedPath;
                scannerForCashing.ScanFolder(folder);
                SetEventLogText("No vira found");
                GC.Collect();
            }
        }


        private void Button3Click(object sender, EventArgs e)
        {

            var timer = new Timer((ex) =>
            {
                var backgroundScanner = new BackgroundWorker();
                backgroundScanner.WorkerReportsProgress = true;
                backgroundScanner.WorkerSupportsCancellation = true;
                backgroundScanner.DoWork += this.ScanServices;
                backgroundScanner.RunWorkerAsync();

            }, null, 0, Convert.ToInt32(TimeSpan.FromMinutes(10.0).TotalMilliseconds));
        }

        private void FrmMainResize(object sender, DoWorkEventArgs e)
        {
            notifyIcon1.DoubleClick += this.TrayManagement;
        }

        public void TrayManagement(object sender, EventArgs e)
        {
            if (FormWindowState.Minimized == this.WindowState)
            {
                notifyIcon1.Visible = false;
                this.ShowInTaskbar = true;
                this.Activate();
                this.Visible = true;
                this.Show();
            }
            if (FormWindowState.Normal == this.WindowState)
            {
                notifyIcon1.Visible = false;
                this.ShowInTaskbar = true;
                this.Activate();
                this.Visible = true;
                this.Show();
            }
        }


        private void Form1Resize(object sender, EventArgs e)
        {
            if (WindowState == FormWindowState.Minimized)
            {
                notifyIcon1.Visible = true;
                this.ShowInTaskbar = false;
                this.Hide();
            }
        }

        public void FolderWatcher(object sender, DoWorkEventArgs e)
        {

            var startUpFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.Startup);
            FileSystemWatcher watcher = new FileSystemWatcher();
            watcher.Path = startUpFolderPath;
            watcher.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName
                                   | NotifyFilters.DirectoryName;
            watcher.Created += this.OnStartupChanged;
            watcher.EnableRaisingEvents = true;

            var startUpFolder1 = Environment.GetFolderPath(Environment.SpecialFolder.CommonStartup);
            FileSystemWatcher watcherAllusers = new FileSystemWatcher();
            watcherAllusers.Path = startUpFolder1;
            watcherAllusers.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite
                                           | NotifyFilters.FileName | NotifyFilters.DirectoryName;
            watcherAllusers.Created += this.OnStartupChanged;
            watcherAllusers.EnableRaisingEvents = true;
        }

        public void OnStartupChanged(object sender, EventArgs e)
        {
            try
            {
                var startUpFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.Startup);
                scannerForCashing.ScanFolder(startUpFolderPath);
                RichTextBox("Startup Folder Scanned." + Environment.NewLine);
                RichTextBoxScroll();
            }
            catch (Exception)
            {

                RichTextBox("Startup Folder Scan Error." + Environment.NewLine);
                RichTextBoxScroll();
            }

        }

        public void ScanServices(object sender, DoWorkEventArgs e)
        {
            RichTextBox("Scanning Windows Services." + Environment.NewLine);
            Scanning(true);
        }

        public void Scanning(bool messages)
        {
            List<string> registry = new List<string>();
            //var dictionary = new Dictionary<string, bool>();
            m_CancelTokenSource = new CancellationTokenSource();
            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = m_CancelTokenSource.Token;
            // Create New Scanner
            foreach (ServiceController sc in ServiceController.GetServices())
            {
                var pathToService =
                    Registry.GetValue(
                        String.Format("HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\{0}", sc.ServiceName),
                        "ImagePath", Empty).ToString().Split('-');
                var res = Regex.Replace(pathToService[0], "^\"([^\"]*)\".*$", "$1").Split('/')[0];
                if (!pathToService.Equals(string.Empty))
                {
                    registry.Add(GetMd5HashOfAFile(res));
                }

                registry = registry.Distinct().ToList();
                registry.Sort();
            }
            foreach (var md5 in registry)
            {
                var scanningTask = Task.Factory.StartNew(() =>
                {
                    // If cancel has been chosen, throw an exception now before doing anything.
                    readFileCancelToken.ThrowIfCancellationRequested();
                    try
                    {
                        if (!md5.Equals(string.Empty))
                        {
                            var boolHolder = scannerForCashing.ScanFile(md5 + "$", 4);
                            //dictionary.Add(sc.ServiceName, !boolHolder);
                            if (messages)
                            {
                                RichTextBox(
                                    "Scanning Windows Services: " + md5.Split('/').Last() + " Is clear?: " + !boolHolder
                                    + Environment.NewLine);
                                RichTextBoxScroll();
                            }
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        //
                    }
                    catch (Exception ex)
                    {
                        if (messages)
                        {
                            RichTextBox("Scanning of service failed: " + ex.Message + Environment.NewLine);
                            RichTextBoxScroll();
                        }
                    }
                    finally
                    {
                        GC.KeepAlive(cashing);
                        GC.KeepAlive(scannerForCashing);
                        GC.Collect();
                    }
                }, readFileCancelToken);

                if (!messages)
                {
                    Task.WaitAll(scanningTask);
                }

            }
        }

        public static string GetPathOfService(string serviceName)
        {
            WqlObjectQuery wqlObjectQuery =
                new WqlObjectQuery(Format("SELECT * FROM Win32_Service WHERE Name = '{0}'", serviceName));
            ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher(wqlObjectQuery);
            ManagementObjectCollection managementObjectCollection = managementObjectSearcher.Get();

            foreach (var o in managementObjectCollection)
            {
                var managementObject = (ManagementObject)o;
                return managementObject.GetPropertyValue("PathName").ToString();
            }

            return null;
        }


        public void Monitor(object sender, DoWorkEventArgs e)
        {
            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_LOCAL_MACHINE_Run = new RegistryMonitor(RegistryHive.LocalMachine,
                "Software\\Microsoft\\Windows\\CurrentVersion\\Run");
            HKEY_LOCAL_MACHINE_Run.RegChanged += OnRegChanged;
            HKEY_LOCAL_MACHINE_Run.Start();

            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_LOCAL_MACHINE_RunOnce = new RegistryMonitor(RegistryHive.LocalMachine,
                "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
            HKEY_LOCAL_MACHINE_RunOnce.RegChanged += OnRegChanged;
            HKEY_LOCAL_MACHINE_RunOnce.Start();

            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_CURRENT_USER_Run = new RegistryMonitor(RegistryHive.CurrentUser,
                "Software\\Microsoft\\Windows\\CurrentVersion\\Run");
            HKEY_CURRENT_USER_Run.RegChanged += OnRegChanged;
            HKEY_CURRENT_USER_Run.Start();

            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_CURRENT_USER_RunOnce = new RegistryMonitor(RegistryHive.LocalMachine,
                "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
            HKEY_CURRENT_USER_RunOnce.RegChanged += OnRegChanged;
            HKEY_CURRENT_USER_RunOnce.Start();

            if (e.Cancel)
            {
                HKEY_LOCAL_MACHINE_Run.Stop();
                HKEY_LOCAL_MACHINE_RunOnce.Stop();
                HKEY_CURRENT_USER_Run.Stop();
                HKEY_CURRENT_USER_RunOnce.Stop();
            }
        }

        public void OnRegChanged(object sender, EventArgs e)
        {
            RichTextBox("Changes to startup registry." + Environment.NewLine);
            RichTextBoxScroll();

            // Startup changed - scan
            BuildStartup(true);
        }

        public void WaitForProcess()
        {
            ManagementEventWatcher processStartEvent = new ManagementEventWatcher("SELECT * FROM Win32_ProcessStartTrace");
            processStartEvent.EventArrived += new EventArrivedEventHandler(StartWatchEventArrived);
            processStartEvent.Start();
            //ManagementEventWatcher startWatch = new ManagementEventWatcher(
            //    new WqlEventQuery("SELECT * FROM Win32_ProcessStartTrace"));
            //startWatch.EventArrived
            //    += this.StartWatchEventArrived;
            //startWatch.Start();

            ManagementEventWatcher stopWatch = new ManagementEventWatcher(
                new WqlEventQuery("SELECT * FROM Win32_ProcessStopTrace"));
            stopWatch.EventArrived
                += this.StopWatchEventArrived;
            stopWatch.Start();
        }

        public void StopWatchEventArrived(object sender, EventArrivedEventArgs e)
        {
            RichTextBox(
                $"Process stopped: {e.NewEvent.Properties["ProcessName"].Value}" + " -with id: " +
                e.NewEvent.Properties["ProcessID"].Value + Environment.NewLine);
            RichTextBoxScroll();

        }

        private readonly HashSet<string> cashing = new HashSet<string>();

        public void StartWatchEventArrivedServices(object sender, EventArrivedEventArgs e)
        {
            RichTextBox($"Service started: {e}");

            // Service Started - scan
            Scanning(true);
        }

        public void StopWatchEventArrivedServices(object sender, EventArrivedEventArgs e)
        {
            RichTextBox($"Service stopped: {e}");
        }

        [Flags]
        public enum ThreadAccess : int
        {
            TERMINATE = (0x0001),
            SUSPEND_RESUME = (0x0002),
            GET_CONTEXT = (0x0008),
            SET_CONTEXT = (0x0010),
            SET_INFORMATION = (0x0020),
            QUERY_INFORMATION = (0x0040),
            SET_THREAD_TOKEN = (0x0080),
            IMPERSONATE = (0x0100),
            DIRECT_IMPERSONATION = (0x0200)
        }

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

        [DllImport("kernel32.dll")]
        static extern uint SuspendThread(IntPtr hThread);

        [DllImport("kernel32.dll")]
        static extern int ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool CloseHandle(IntPtr hObject);

        public Process ContinueProcess;

        public void StartWatchEventArrived(object sender, EventArrivedEventArgs e)
        {
            var stopWatch = new Stopwatch();
            stopWatch.Start();
            //m_CancelTokenSource = new CancellationTokenSource();

            // Get a reference to the cancellation token.
            //CancellationToken readFileCancelToken = m_CancelTokenSource.Token;
            Task.Run(() =>
            {
                // If cancel has been chosen, throw an exception now before doing anything.
                // readFileCancelToken.ThrowIfCancellationRequested();
                var processId = e.NewEvent.Properties["ProcessID"].Value;
                var process = Process.GetProcessById(Int32.Parse(processId.ToString()));
                try
                {
                    var fileName = process.MainModule.FileName;
                    var md5String = GetMd5HashOfAFile(fileName);
                    try
                    {
                        if (cashing.Contains(md5String))
                        {
                            stopWatch.Stop();
                            RichTextBox(
                                $"Process already scanned {e.NewEvent.Properties["ProcessName"].Value}"
                                + " ProcessID: " + processId + Environment.NewLine);
                            RichTextBoxScroll();
                            var directory = Thread.GetDomain().BaseDirectory + "\\ScanTime\\";
                            File.AppendAllText(directory + "RemoveVirusTime.txt", fileName + @" -- Cachscanned in: " + stopWatch.Elapsed.Milliseconds + Environment.NewLine);
                        }
                        else
                        {
                            var result = scannerForCashing.ScanFile(md5String.ToLower() + "$", 4);
                            stopWatch.Stop();
                            if (result)
                            {
                                var lockedProcesses = FileUtil.WhoIsLocking(fileName).ToList();
                                foreach (var lockedProcess in lockedProcesses)
                                {
                                    lockedProcess.Kill();
                                }
                                // Kill process as fast as possible
                                process.Kill();

                                var directory = Thread.GetDomain().BaseDirectory + "\\ScanTime\\";
                                File.AppendAllText(directory + "RemoveVirusTime.txt", fileName + @" -- Removed in: " + stopWatch.Elapsed.Milliseconds + Environment.NewLine);
                                File.SetAttributes(fileName, FileAttributes.Normal);
                                var databaseDirectory = Thread.GetDomain().BaseDirectory + "Quarantine\\";
                                var filenameWithoutExrtension = Path.GetFileNameWithoutExtension(fileName);
                                if (File.Exists(databaseDirectory + filenameWithoutExrtension + ".qua"))
                                {
                                    File.Delete(databaseDirectory + filenameWithoutExrtension + ".qua");
                                }
                                File.Move(fileName, databaseDirectory + filenameWithoutExrtension + ".qua");
                                SetNotificationText(Path.GetFileName(fileName) + " ---- is a virus -- Quarantined");
                            }
                            else
                            {
                                stopWatch.Stop();
                                var directory = Thread.GetDomain().BaseDirectory + "\\ScanTime\\";
                                File.AppendAllText(directory + "RemoveVirusTime.txt", fileName + @" -- Scanned in: " + stopWatch.Elapsed + Environment.NewLine);
                                this.cashing.Add(md5String);
                                RichTextBox($"Process scanned {e.NewEvent.Properties["ProcessName"].Value}" + " ProcessID: " + processId + Environment.NewLine);
                                RichTextBoxScroll();
                            }
                        }
                        GC.KeepAlive(cashing);
                        GC.KeepAlive(scannerForCashing);
                        GC.Collect();
                    }
                    catch (Exception ex)
                    {
                        RichTextBox("Error 5: " + ex.Message + Environment.NewLine);
                        RichTextBoxScroll();
                    }
                }
                catch (Exception)
                {
                    //
                }
                finally
                {
                    GC.KeepAlive(cashing);
                    GC.KeepAlive(scannerForCashing);
                    GC.Collect();
                }
            });
        }


        public void Testprocess(EventArrivedEventArgs e, Process process)
        {
            try
            {
                var fileName = process.MainModule.FileName;
                var md5String = GetMd5HashOfAFile(fileName);
                ProcessText($"{DateTime.Now.Hour}:{DateTime.Now.Minute}:{DateTime.Now.Second} - {fileName}");
                if (cashing.Contains(md5String))
                {
                    // resume threads
                    foreach (ProcessThread pT in process.Threads)
                    {
                        IntPtr pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)pT.Id);

                        if (pOpenThread == IntPtr.Zero)
                        {
                            continue;
                        }

                        var suspendCount = 0;
                        do
                        {
                            suspendCount = ResumeThread(pOpenThread);
                        } while (suspendCount > 0);

                        CloseHandle(pOpenThread);
                    }
                    RichTextBox(
                        $"Process already scanned {e.NewEvent.Properties["ProcessName"].Value}"
                        + " ProcessID: " + process.Id + Environment.NewLine);
                    RichTextBoxScroll();
                }
                else
                {

                    var result = scannerForCashing.ScanFile(md5String.ToLower() + "$", 4);
                    RichTextBox(
                        $"Process scanned {e.NewEvent.Properties["ProcessName"].Value}"
                        + " ProcessID: " + process.Id + Environment.NewLine);
                    RichTextBoxScroll();
                    if (result)
                    {
                        SetNotificationText(Path.GetFileName(fileName) + " ---- is a virus -- Quarantined");

                        var lockedProcesses = FileUtil.WhoIsLocking(fileName).ToList();
                        foreach (var lockedProcess in lockedProcesses)
                        {
                            lockedProcess.Kill();
                        }
                        try
                        {
                            foreach (ProcessThread pT in process.Threads)
                            {
                                IntPtr pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)pT.Id);
                                //TerminateThread(pOpenThread, 0);
                                SuspendThread(pOpenThread);
                            }
                            process?.Kill();
                        }
                        catch (Exception ex)
                        {

                            RichTextBox("Error 102: " + ex.Message + Environment.NewLine);
                            RichTextBoxScroll();
                        }
                        File.SetAttributes(fileName, FileAttributes.Normal);
                        var databaseDirectory = Thread.GetDomain().BaseDirectory + "Quarantine\\";
                        if (File.Exists(databaseDirectory + fileName + "." + md5String))
                            File.Delete(databaseDirectory + fileName + "." + md5String);
                        var file = Path.GetFileNameWithoutExtension(fileName);
                        File.Move(fileName, databaseDirectory + file + "." + md5String);
                    }
                    else
                    {
                        this.cashing.Add(md5String);
                        foreach (ProcessThread pT in process.Threads)
                        {
                            IntPtr pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)pT.Id);

                            if (pOpenThread == IntPtr.Zero)
                            {
                                continue;
                            }

                            var suspendCount = 0;
                            do
                            {
                                suspendCount = ResumeThread(pOpenThread);
                            } while (suspendCount > 0);

                            CloseHandle(pOpenThread);
                        }
                    }
                }
                GC.KeepAlive(cashing);
                GC.KeepAlive(scannerForCashing);
                GC.Collect();
            }
            catch (Exception ex)
            {
                RichTextBox("Error 1: " + ex.Message + Environment.NewLine);
                RichTextBoxScroll();
            }
        }

        public void CreateStartupImageClick(object sender, EventArgs e)
        {
            BuildStartup(true);
        }

        public void BuildStartup(bool messages)
        {
            m_CancelTokenSource = new CancellationTokenSource();
            var startupDict = new Dictionary<string, string>();

            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = m_CancelTokenSource.Token;
            var gettingStratupTask = Task.Factory.StartNew(() =>
           {
               string filepath = "";
               // If cancel has been chosen, throw an exception now before doing anything.
               readFileCancelToken.ThrowIfCancellationRequested();
               try
               {
                   ProcessStartInfo startInfo = new ProcessStartInfo
                   {
                       FileName = "cmd.exe",
                       WindowStyle = ProcessWindowStyle.Hidden,
                       UseShellExecute = false,
                       CreateNoWindow = true,
                       RedirectStandardOutput = true,
                       Arguments = Format("/c" + "autorunsc.exe " + "-a * -h user -nobanner")
                   };
                   try
                   {
                       // Start the process with the info we specified.
                       // Call WaitForExit and then the using statement will close.
                       using (Process exeProcess = Process.Start(startInfo))
                       {
                           if (exeProcess != null)
                           {
                               exeProcess.Start();
                               string standardOutput;
                               while ((standardOutput = exeProcess.StandardOutput.ReadLine()) != null)
                               {
                                   var environmentVariable = Environment.GetEnvironmentVariable("SystemRoot");
                                   if (environmentVariable != null)
                                   {
                                       var windownInstallRoot = environmentVariable.Replace("WINDOWS", string.Empty).ToLower();
                                       if (standardOutput.Contains(windownInstallRoot))
                                       {
                                           filepath = standardOutput;

                                       }
                                   }
                                   if (standardOutput.Contains("MD5"))
                                   {
                                       if (standardOutput.Split(':').Length >= 2)
                                       {
                                           var puremd5 = standardOutput.Split(':')[1].Trim().ToLower();
                                           if (!puremd5.Equals(string.Empty) && !startupDict.Keys.Contains(puremd5 + "$") && puremd5.Length.Equals(32))
                                           {
                                               startupDict.Add(puremd5 + "$", filepath);
                                               var result = scannerForCashing.ScanFile(puremd5 + "$", 4);
                                               if (messages)
                                               {
                                                   if (result)
                                                   {
                                                       // There is a virus
                                                       this.RichTextBox(filepath + " IS INFECTED." + Environment.NewLine);
                                                       RichTextBoxScroll();

                                                   }
                                                   else
                                                   {
                                                       this.RichTextBox(filepath + " IS CLEAR." + Environment.NewLine);
                                                       RichTextBoxScroll();

                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                               exeProcess.WaitForExit();
                           }
                           GC.KeepAlive(cashing);
                           GC.KeepAlive(scannerForCashing);
                           GC.Collect();
                       }

                   }
                   catch (NullReferenceException)
                   {
                       if (messages)
                       {
                           this.RichTextBox("Startup Data Creation Failed!");
                           RichTextBoxScroll();
                       }
                   }
               }
               catch (OperationCanceledException)
               {
                   //
               }
               catch (Exception ex)
               {
                   if (messages)
                   {
                       RichTextBox("1: Startup Data Creation Failed! " + ex.Message + Environment.NewLine + filepath +
                                   ex.StackTrace);
                       RichTextBoxScroll();
                   }
               }
               finally
               {
                   GC.KeepAlive(scannerForCashing);
                   GC.KeepAlive(cashing);
                   GC.Collect();
               }
           }, readFileCancelToken);

            if (!messages)
            {
                Task.WaitAll(gettingStratupTask);
            }
        }

        public void ScanningList(string md5, string file, bool messages)
        {
            //this.RichTextBox("Scanning startup file: " + file);
            m_CancelTokenSource = new CancellationTokenSource();
            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = m_CancelTokenSource.Token;
            Task.Factory.StartNew(() =>
            {
                // If cancel has been chosen, throw an exception now before doing anything.
                readFileCancelToken.ThrowIfCancellationRequested();
                try
                {
                    var result = scannerForCashing.ScanFile(md5, 4);
                    if (result)
                    {
                        if (messages)
                        {
                            // There is a virus
                            this.RichTextBox(file + " IS INFECTED." + Environment.NewLine);
                            RichTextBoxScroll();
                        }
                    }
                    else
                    {
                        if (messages)
                        {
                            this.RichTextBox(file + " IS CLEAR." + Environment.NewLine);
                            RichTextBoxScroll();
                        }
                    }

                }
                catch (OperationCanceledException)
                {
                    //
                }
                catch (Exception)
                {
                    if (messages)
                    {
                        RichTextBox("SOMETHING WENT WRONG!!!" + Environment.NewLine);
                        RichTextBoxScroll();
                    }
                }
                finally
                {
                    GC.KeepAlive(cashing);

                    // Need to keep scanner alive
                    GC.KeepAlive(scannerForCashing);
                    GC.Collect();
                }
            }, readFileCancelToken);

        }


        public string GetMd5HashOfAFile(string file)
        {
            MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
            FileStream stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read, 8192);
            md5.ComputeHash(stream);
            stream.Close();

            byte[] hash = md5.Hash;
            return BitConverter.ToString(hash).Replace("-", "").ToLower();
        }


        private void OnFormClosing(object sender, CancelEventArgs e)
        {
            e.Cancel = true;
            notifyIcon1.Visible = true;
            this.ShowInTaskbar = false;
            this.Hide();
            scannerForCashing.SaveCashedValues();
        }




        /// <summary>
        /// Taken from http://www.tech-archive.net/Archive/VB/microsoft.public.vb.winapi/2006-08/msg00238.html, all credits goes to the developers
        /// d. 31-12-2016 kl. 10:27.
        /// </summary>
        public static class ServiceInstaller
        {
            private const int StandardRightsRequired = 0xF0000;
            private const int ServiceWin32OwnProcess = 0x00000010;

            [StructLayout(LayoutKind.Sequential)]
            private class ServiceStatus
            {
                public int dwServiceType = 0;
                public ServiceState dwCurrentState = 0;
                public int dwControlsAccepted = 0;
                public int dwWin32ExitCode = 0;
                public int dwServiceSpecificExitCode = 0;
                public int dwCheckPoint = 0;
                public int dwWaitHint = 0;
            }

            #region OpenSCManager
            [DllImport("advapi32.dll", EntryPoint = "OpenSCManagerW", ExactSpelling = true, CharSet = CharSet.Unicode, SetLastError = true)]
            static extern IntPtr OpenSCManager(string machineName, string databaseName, ScmAccessRights dwDesiredAccess);
            #endregion

            #region OpenService
            [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
            static extern IntPtr OpenService(IntPtr hScManager, string lpServiceName, ServiceAccessRights dwDesiredAccess);
            #endregion

            #region CreateService
            [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
            private static extern IntPtr CreateService(IntPtr hScManager, string lpServiceName, string lpDisplayName, ServiceAccessRights dwDesiredAccess, int dwServiceType, ServiceBootFlag dwStartType, ServiceError dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, IntPtr lpdwTagId, string lpDependencies, string lp, string lpPassword);
            #endregion

            #region CloseServiceHandle
            [DllImport("advapi32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            static extern bool CloseServiceHandle(IntPtr hSCObject);
            #endregion

            #region QueryServiceStatus
            [DllImport("advapi32.dll")]
            private static extern int QueryServiceStatus(IntPtr hService, ServiceStatus lpServiceStatus);
            #endregion

            #region DeleteService
            [DllImport("advapi32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool DeleteService(IntPtr hService);
            #endregion

            #region ControlService
            [DllImport("advapi32.dll")]
            private static extern int ControlService(IntPtr hService, ServiceControl dwControl, ServiceStatus lpServiceStatus);
            #endregion

            #region StartService
            [DllImport("advapi32.dll", SetLastError = true)]
            private static extern int StartService(IntPtr hService, int dwNumServiceArgs, int lpServiceArgVectors);
            #endregion

            public static void Uninstall(string serviceName)
            {
                IntPtr scm = OpenSCManager(ScmAccessRights.AllAccess);

                try
                {
                    IntPtr service = OpenService(scm, serviceName, ServiceAccessRights.AllAccess);
                    if (service == IntPtr.Zero)
                        throw new ApplicationException("Service not installed.");

                    try
                    {
                        StopService(service);
                        if (!DeleteService(service))
                            throw new ApplicationException("Could not delete service " + Marshal.GetLastWin32Error());
                    }
                    finally
                    {
                        CloseServiceHandle(service);
                    }
                }
                finally
                {
                    CloseServiceHandle(scm);
                }
            }

            public static bool ServiceIsInstalled(string serviceName)
            {
                IntPtr scm = OpenSCManager(ScmAccessRights.Connect);

                try
                {
                    IntPtr service = OpenService(scm, serviceName, ServiceAccessRights.QueryStatus);

                    if (service == IntPtr.Zero)
                        return false;

                    CloseServiceHandle(service);
                    return true;
                }
                finally
                {
                    CloseServiceHandle(scm);
                }
            }

            public static void InstallAndStart(string serviceName, string displayName, string fileName)
            {
                IntPtr scm = OpenSCManager(ScmAccessRights.AllAccess);

                try
                {
                    IntPtr service = OpenService(scm, serviceName, ServiceAccessRights.AllAccess);

                    if (service == IntPtr.Zero)
                        service = CreateService(scm, serviceName, displayName, ServiceAccessRights.AllAccess, ServiceWin32OwnProcess, ServiceBootFlag.AutoStart, ServiceError.Normal, fileName, null, IntPtr.Zero, null, null, null);

                    if (service == IntPtr.Zero)
                        throw new ApplicationException("Failed to install service.");

                    try
                    {
                        StartService(service);
                    }
                    finally
                    {
                        CloseServiceHandle(service);
                    }
                }
                finally
                {
                    CloseServiceHandle(scm);
                }
            }

            public static void StartService(string serviceName)
            {
                IntPtr scm = OpenSCManager(ScmAccessRights.Connect);

                try
                {
                    IntPtr service = OpenService(scm, serviceName, ServiceAccessRights.QueryStatus | ServiceAccessRights.Start);
                    if (service == IntPtr.Zero)
                        throw new ApplicationException("Could not open service.");

                    try
                    {
                        StartService(service);
                    }
                    finally
                    {
                        CloseServiceHandle(service);
                    }
                }
                finally
                {
                    CloseServiceHandle(scm);
                }
            }

            public static void StopService(string serviceName)
            {
                IntPtr scm = OpenSCManager(ScmAccessRights.Connect);

                try
                {
                    IntPtr service = OpenService(scm, serviceName, ServiceAccessRights.QueryStatus | ServiceAccessRights.Stop);
                    if (service == IntPtr.Zero)
                        throw new ApplicationException("Could not open service.");

                    try
                    {
                        StopService(service);
                    }
                    finally
                    {
                        CloseServiceHandle(service);
                    }
                }
                finally
                {
                    CloseServiceHandle(scm);
                }
            }

            private static void StartService(IntPtr service)
            {
                ServiceStatus status = new ServiceStatus();
                StartService(service, 0, 0);
                var changedStatus = WaitForServiceStatus(service, ServiceState.StartPending, ServiceState.Running);
                if (!changedStatus)
                    throw new ApplicationException("Unable to start service");
            }

            private static void StopService(IntPtr service)
            {
                ServiceStatus status = new ServiceStatus();
                ControlService(service, ServiceControl.Stop, status);
                var changedStatus = WaitForServiceStatus(service, ServiceState.StopPending, ServiceState.Stopped);
                if (!changedStatus)
                    throw new ApplicationException("Unable to stop service");
            }

            public static ServiceState GetServiceStatus(string serviceName)
            {
                IntPtr scm = OpenSCManager(ScmAccessRights.Connect);

                try
                {
                    IntPtr service = OpenService(scm, serviceName, ServiceAccessRights.QueryStatus);
                    if (service == IntPtr.Zero)
                        return ServiceState.NotFound;

                    try
                    {
                        return GetServiceStatus(service);
                    }
                    finally
                    {
                        CloseServiceHandle(service);
                    }
                }
                finally
                {
                    CloseServiceHandle(scm);
                }
            }

            private static ServiceState GetServiceStatus(IntPtr service)
            {
                ServiceStatus status = new ServiceStatus();

                if (QueryServiceStatus(service, status) == 0)
                    throw new ApplicationException("Failed to query service status.");

                return status.dwCurrentState;
            }

            private static bool WaitForServiceStatus(IntPtr service, ServiceState waitStatus, ServiceState desiredStatus)
            {
                ServiceStatus status = new ServiceStatus();

                QueryServiceStatus(service, status);
                if (status.dwCurrentState == desiredStatus) return true;

                int dwStartTickCount = Environment.TickCount;
                int dwOldCheckPoint = status.dwCheckPoint;

                while (status.dwCurrentState == waitStatus)
                {
                    // Do not wait longer than the wait hint. A good interval is
                    // one tenth the wait hint, but no less than 1 second and no
                    // more than 10 seconds.

                    int dwWaitTime = status.dwWaitHint / 10;

                    if (dwWaitTime < 1000) dwWaitTime = 1000;
                    else if (dwWaitTime > 10000) dwWaitTime = 10000;

                    Thread.Sleep(dwWaitTime);

                    // Check the status again.

                    if (QueryServiceStatus(service, status) == 0) break;

                    if (status.dwCheckPoint > dwOldCheckPoint)
                    {
                        // The service is making progress.
                        dwStartTickCount = Environment.TickCount;
                        dwOldCheckPoint = status.dwCheckPoint;
                    }
                    else
                    {
                        if (Environment.TickCount - dwStartTickCount > status.dwWaitHint)
                        {
                            // No progress made within the wait hint
                            break;
                        }
                    }
                }
                return (status.dwCurrentState == desiredStatus);
            }

            private static IntPtr OpenSCManager(ScmAccessRights rights)
            {
                IntPtr scm = OpenSCManager(null, null, rights);
                if (scm == IntPtr.Zero)
                    throw new ApplicationException("Could not connect to service control manager.");

                return scm;
            }
        }


        public enum ServiceState
        {
            Unknown = -1, // The state cannot be (has not been) retrieved.
            NotFound = 0, // The service is not known on the host server.
            Stopped = 1,
            StartPending = 2,
            StopPending = 3,
            Running = 4,
            ContinuePending = 5,
            PausePending = 6,
            Paused = 7
        }

        [Flags]
        public enum ScmAccessRights
        {
            Connect = 0x0001,
            CreateService = 0x0002,
            EnumerateService = 0x0004,
            Lock = 0x0008,
            QueryLockStatus = 0x0010,
            ModifyBootConfig = 0x0020,
            StandardRightsRequired = 0xF0000,
            AllAccess = (StandardRightsRequired | Connect | CreateService |
                         EnumerateService | Lock | QueryLockStatus | ModifyBootConfig)
        }

        [Flags]
        public enum ServiceAccessRights
        {
            QueryConfig = 0x1,
            ChangeConfig = 0x2,
            QueryStatus = 0x4,
            EnumerateDependants = 0x8,
            Start = 0x10,
            Stop = 0x20,
            PauseContinue = 0x40,
            Interrogate = 0x80,
            UserDefinedControl = 0x100,
            Delete = 0x00010000,
            StandardRightsRequired = 0xF0000,
            AllAccess = (StandardRightsRequired | QueryConfig | ChangeConfig |
                         QueryStatus | EnumerateDependants | Start | Stop | PauseContinue |
                         Interrogate | UserDefinedControl)
        }

        public enum ServiceBootFlag
        {
            Start = 0x00000000,
            SystemStart = 0x00000001,
            AutoStart = 0x00000002,
            DemandStart = 0x00000003,
            Disabled = 0x00000004
        }

        public enum ServiceControl
        {
            Stop = 0x00000001,
            Pause = 0x00000002,
            Continue = 0x00000003,
            Interrogate = 0x00000004,
            Shutdown = 0x00000005,
            ParamChange = 0x00000006,
            NetBindAdd = 0x00000007,
            NetBindRemove = 0x00000008,
            NetBindEnable = 0x00000009,
            NetBindDisable = 0x0000000A
        }

        public enum ServiceError
        {
            Ignore = 0x00000000,
            Normal = 0x00000001,
            Severe = 0x00000002,
            Critical = 0x00000003
        }


        private void StartBackgroundWork()
        {

            progressBar1.Style = ProgressBarStyle.Marquee;
            progressBar1.Maximum = 100000;
            progressBar1.Value = 0;
            progressBar1.Enabled = true;
            progressBar1.Step = 5;

            var backgroundWorker = new BackgroundWorker();
            backgroundWorker.WorkerReportsProgress = true;
            backgroundWorker.WorkerSupportsCancellation = true;
            backgroundWorker.DoWork += timer_Tick;
            backgroundWorker.RunWorkerAsync();
        }

        private void timer_Tick(object sender, EventArgs e)
        {
            if (ServiceInstaller.ServiceIsInstalled("Malware Detection Scanner"))
            {
                var startAgain = true;
                while (true)
                {
                    if (progressBar1.Value < progressBar1.Maximum)
                    {
                        if (ServiceInstaller.GetServiceStatus("Malware Detection Scanner") == ServiceState.Stopped ||
                            ServiceInstaller.GetServiceStatus("Malware Detection Scanner") == ServiceState.Paused)
                        {
                            ProgreeStyleMarquee();
                            ProgressSpeed(0);
                            ProgresValue(0);
                        }
                        else
                        {

                            ProgressStyleContinious();
                            ProgressSpeed(1);
                            ProgressIncrement();
                        }
                    }
                    else
                    {
                        ProgreeMinimum();
                    }

                }
            }
        }
    }
}

