/*
 Copyright (c) 2016 Mark Roland
 University of Copenhagen, Department of Computer Science

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

using System.Runtime.CompilerServices;
using Roland_IO_Malware;

namespace MalwareDetectionSystem
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.ServiceProcess;
    using System.Threading;
    using System.Diagnostics;
    using System.Security.Cryptography;
    using Microsoft.Win32;
    using System.Management;
    using System.Linq;
    using System.Runtime;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;

    /// <summary>
    /// The service 1.
    /// </summary>
    public partial class MalwareDetectionSystem : ServiceBase
    {

        private Scanner _scannerForCashing = new Scanner();

        private BackgroundWorker _scanWindowsServices;

        private BackgroundWorker _folderWatcher;

        private BackgroundWorker _processWatcher;

        private string _workingDirectory;

        internal enum Service1EventIds
        {
            InitializationGeneralFailure = 100,
            InitializationWatcherDirNotExist = 101,
            InitializationWatcherDirNoAccess = 102,
            InitializationWatcherDirOtherError = 103,
            StartGeneralFailure = 200,
            StartInitializationFailure = 201,
            StopGeneralFailure = 300
        }

        /// <summary>
        /// The on start.
        /// </summary>
        /// <param name="args">
        /// The args.
        /// </param>
        protected override void OnStart(string[] args)
        {
            try
            {
                _scannerForCashing.LoadCashedValues();
                String path = System.Reflection.Assembly.GetExecutingAssembly().Location;
                path = Path.GetDirectoryName(path);
                if (path != null) Directory.SetCurrentDirectory(path);
                _workingDirectory = path + @"\";
                if (!File.Exists(_workingDirectory + "ServiceTest.txt"))
                {
                    // Create a file to write to. 
                    using (
                        StreamWriter sw = File.CreateText(_workingDirectory + "ServiceTest.txt" + Environment.NewLine))
                    {
                        sw.WriteLine("Hello world, the service has started: ");
                    }
                }
                else
                {
                    File.AppendAllText(_workingDirectory + "ServiceTest.txt", DateTime.Now + "  -- Hello world, the service has started: " + Environment.NewLine);
                }
                InitializeComponent();
                GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
                BuildStartup();

                // Save the values as cashe to file
                _scannerForCashing.SaveCashedValues();

                // Clear cashe to ensure that bew values are writte to file
                _scannerForCashing.ClearMd5Values();

                this._processWatcher = new BackgroundWorker();
                InitializeEventScannerProcessWatcher();
                this._processWatcher.RunWorkerAsync();

                this._scanWindowsServices = new BackgroundWorker();
                InitializeEventScannerWindowsServices();
                _scanWindowsServices.RunWorkerAsync();

                this._folderWatcher = new BackgroundWorker();
                InitializeEventScannerFolderWatcher();
                this._folderWatcher.RunWorkerAsync();

            }
            catch (Exception ex)
            {
                EventLog.WriteEntry("Error: " + ex.StackTrace + Environment.NewLine, EventLogEntryType.Error);
            }
        }

        /// <summary>
        /// The on stop.
        /// </summary>
        protected override void OnStop()
        {
            _scannerForCashing.SaveCashedValues();
            _processWatcher.CancelAsync();
            _folderWatcher.CancelAsync();
            _scanWindowsServices.CancelAsync();
        }

        /// <summary>
        /// The object used for cancelling tasks.
        /// </summary>
        private CancellationTokenSource _mCancelTokenSource;


        /// <summary>
        /// The initialize worker processes.
        /// </summary>
        private void InitializeEventScannerFolderWatcher()
        {
            this._folderWatcher.WorkerReportsProgress = true;
            this._folderWatcher.WorkerSupportsCancellation = true;
            this._folderWatcher.DoWork += this.FolderWatcher;
        }

        /// <summary>
        /// The initialize worker processes.
        /// </summary>
        private void InitializeEventScannerWindowsServices()
        {
            this._scanWindowsServices.WorkerReportsProgress = true;
            this._scanWindowsServices.WorkerSupportsCancellation = true;
            this._scanWindowsServices.DoWork += Monitor;
        }

        /// <summary>
        /// The initialize worker processes.
        /// </summary>
        private void InitializeEventScannerProcessWatcher()
        {
            this._processWatcher.WorkerReportsProgress = true;
            this._processWatcher.WorkerSupportsCancellation = true;
            this._processWatcher.DoWork += this.WaitForProcess;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MalwareDetectionSystem"/> class.
        /// </summary>
        /// <param name="args">
        /// The args.
        /// </param>
        public MalwareDetectionSystem(string[] args)
        {
            InitializeComponent();
            string eventSourceName = "MySource";
            string logName = "MyNewLog";
            if (args.Length > 0)
            {
                eventSourceName = args[0];
            }
            if (args.Length > 1)
            {
                logName = args[1];
            }
            var eventLog1 = new EventLog();
            if (!EventLog.SourceExists(eventSourceName))
            {
                EventLog.CreateEventSource(eventSourceName, logName);
            }

            eventLog1.Source = eventSourceName;
            eventLog1.Log = logName;
        }

        public void Monitor(object sender, DoWorkEventArgs e)
        {
            //// ReSharper disable once InconsistentNaming
            //// ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_LOCAL_MACHINE_Run = new RegistryMonitor(RegistryHive.LocalMachine, "Software\\Microsoft\\Windows\\CurrentVersion\\Run");
            HKEY_LOCAL_MACHINE_Run.RegChanged += OnRegChanged;
            HKEY_LOCAL_MACHINE_Run.Start();

            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_LOCAL_MACHINE_RunOnce = new RegistryMonitor(RegistryHive.LocalMachine, "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
            HKEY_LOCAL_MACHINE_RunOnce.RegChanged += OnRegChanged;
            HKEY_LOCAL_MACHINE_RunOnce.Start();

            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_CURRENT_USER_Run = new RegistryMonitor(RegistryHive.CurrentUser, "Software\\Microsoft\\Windows\\CurrentVersion\\Run");
            HKEY_CURRENT_USER_Run.RegChanged += OnRegChanged;
            HKEY_CURRENT_USER_Run.Start();

            // ReSharper disable once InconsistentNaming
            // ReSharper disable once IdentifierTypo
            RegistryMonitor HKEY_CURRENT_USER_RunOnce = new RegistryMonitor(RegistryHive.LocalMachine, "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
            HKEY_CURRENT_USER_RunOnce.RegChanged += OnRegChanged;
            HKEY_CURRENT_USER_RunOnce.Start();

            if (e.Cancel)
            {
                HKEY_LOCAL_MACHINE_Run.Stop();
                HKEY_LOCAL_MACHINE_RunOnce.Stop();
                HKEY_CURRENT_USER_Run.Stop();
                HKEY_CURRENT_USER_RunOnce.Stop();
            }
        }

        public void OnRegChanged(object sender, EventArgs e)
        {
        }

        public void BuildStartup()
        {

            var startUpFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            File.AppendAllText(_workingDirectory + "ServiceTest.txt", "--- STARTUP WORKING DIR: " + startUpFolderPath + Environment.NewLine);
            _scannerForCashing.ScanFolder(startUpFolderPath);
            //var startUpFolder1 = Environment.GetFolderPath(Environment.SpecialFolder.CommonStartup);
            //_scannerForCashing.ScanFolder(startUpFolder1);

            _mCancelTokenSource = new CancellationTokenSource();
            var startupDict = new Dictionary<string, string>();

            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = _mCancelTokenSource.Token;
            Task.Run(() =>
            {
                string filepath = "";
                // If cancel has been chosen, throw an exception now before doing anything.
                readFileCancelToken.ThrowIfCancellationRequested();
                try
                {
                    String path = System.Reflection.Assembly.GetExecutingAssembly().Location;
                    path = Path.GetDirectoryName(path);
                    if (path != null) Directory.SetCurrentDirectory(path);
                    ProcessStartInfo startInfo = new ProcessStartInfo
                    {
                        FileName = "cmd.exe",
                        WindowStyle = ProcessWindowStyle.Hidden,
                        UseShellExecute = false,
                        CreateNoWindow = false,
                        RedirectStandardOutput = true,
                        Arguments = string.Format("/c " + _workingDirectory + "autorunsc.exe " + "-a * -h * -nobanner -accepteula")
                    };
                    try
                    {
                        // Start the process with the info we specified.
                        // Call WaitForExit and then the using statement will close.
                        using (Process exeProcess = Process.Start(startInfo))
                        {
                            if (exeProcess != null)
                            {
                                exeProcess.Start();
                                string standardOutput;
                                File.AppendAllText(_workingDirectory + "ServiceTest.txt", DateTime.Now + " CMD started: " + path + Environment.NewLine);
                                while ((standardOutput = exeProcess.StandardOutput.ReadLine()) != null)
                                {
                                    var environmentVariable = Environment.GetEnvironmentVariable("SystemRoot");
                                    if (environmentVariable != null)
                                    {
                                        var windownInstallRoot = environmentVariable.Replace("WINDOWS", string.Empty).ToLower();
                                        if (standardOutput.Contains(windownInstallRoot))
                                        {
                                            filepath = standardOutput;

                                        }
                                    }
                                    if (standardOutput.Contains("MD5"))
                                    {
                                        if (standardOutput.Split(':').Length >= 2)
                                        {
                                            var puremd5 = standardOutput.Split(':')[1].Trim().ToLower();
                                            if (!puremd5.Equals(string.Empty) && !startupDict.Keys.Contains(puremd5 + "$") && puremd5.Length.Equals(32))
                                            {
                                                startupDict.Add(puremd5 + "$", filepath);
                                                var result = _scannerForCashing.ScanFile(puremd5 + "$", 4);
                                                if (result)
                                                {

                                                    File.AppendAllText(_workingDirectory + "ServiceTest.txt",
                                                        DateTime.Now + "  -- Buildstartup --  File: " + filepath +
                                                        "   @@@ is infected - moved to quarantine - with: " + puremd5 +
                                                        Environment.NewLine);
                                                    var fileNameWithOutExtension =
                                                        Path.GetFileNameWithoutExtension(filepath);
                                                    var pathToFile = filepath.Replace(Path.GetFileName(filepath),
                                                        string.Empty);
                                                    var currentProcess =
                                                        Process.GetProcessesByName(fileNameWithOutExtension)
                                                            .FirstOrDefault(
                                                                p => p.MainModule.FileName.StartsWith(pathToFile));
                                                    var lockedProcesses = FileUtil.WhoIsLocking(filepath).ToList();
                                                    foreach (var lockedProcess in lockedProcesses)
                                                    {
                                                        lockedProcess.Kill();
                                                    }
                                                    currentProcess?.Kill();
                                                    File.SetAttributes(filepath, FileAttributes.Normal);
                                                    var databaseDirectory = Thread.GetDomain().BaseDirectory +
                                                                            @"Quarantine\";
                                                    //File.Copy(filepath, databaseDirectory + fileNameWithOutExtension.ToLowerInvariant() + ".qua", true);
                                                    File.Delete(filepath);
                                                }
                                                else
                                                {
                                                    File.AppendAllText(_workingDirectory + "ServiceTest.txt",
                                                        DateTime.Now + "  -- Buildstartup --  File: " + filepath + " Scan reported no virus :)" + Environment.NewLine);
                                                }
                                            }
                                        }
                                    }
                                }
                                exeProcess.WaitForExit();
                            }
                            GC.KeepAlive(_cashing);
                            GC.KeepAlive(_scannerForCashing);
                            GC.Collect();
                        }

                    }
                    catch (NullReferenceException ex)
                    {
                        File.AppendAllText(_workingDirectory + "ServiceTest.txt", "Error: " + ex.StackTrace + Environment.NewLine);
                    }
                }
                catch (Exception ex)
                {
                    File.AppendAllText(_workingDirectory + "ServiceTest.txt", "Error: " + ex.StackTrace + Environment.NewLine);
                }
                finally
                {
                    GC.KeepAlive(_scannerForCashing);
                    GC.KeepAlive(_cashing);
                    GC.Collect();
                }
            }, readFileCancelToken);
        }


        public void WaitForProcess(object sender, DoWorkEventArgs e)
        {
            ManagementEventWatcher startWatch = new ManagementEventWatcher(
              new WqlEventQuery("SELECT * FROM Win32_ProcessStartTrace"));
            startWatch.EventArrived
                                += this.StartWatchEventArrived;
            startWatch.Start();

            ManagementEventWatcher stopWatch = new ManagementEventWatcher(
              new WqlEventQuery("SELECT * FROM Win32_ProcessStopTrace"));
            stopWatch.EventArrived
                                += this.StopWatchEventArrived;
            stopWatch.Start();
        }

        public void StopWatchEventArrived(object sender, EventArrivedEventArgs e)
        {
            // Process stopped

        }

        private readonly HashSet<string> _cashing = new HashSet<string>();

        public void StartWatchEventArrivedServices(object sender, EventArrivedEventArgs e)
        {
            Scanning();
        }

        public void StopWatchEventArrivedServices(object sender, EventArrivedEventArgs e)
        {
            //  Service is stopped
        }

        public string GetMd5HashOfAFile(string file)
        {
            MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
            FileStream stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read, 8192);
            md5.ComputeHash(stream);
            stream.Close();

            byte[] hash = md5.Hash;
            return BitConverter.ToString(hash).Replace("-", "").ToLower();
        }

        public void StartWatchEventArrived(object sender, EventArrivedEventArgs e)
        {
            _mCancelTokenSource = new CancellationTokenSource();

            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = _mCancelTokenSource.Token;

            Task.Run(() =>
            {
                // If cancel has been chosen, throw an exception now before doing anything.
                readFileCancelToken.ThrowIfCancellationRequested();
                var processId = e.NewEvent.Properties["ProcessID"].Value;
                var process = new Process();
                try
                {
                    process = Process.GetProcessById(Int32.Parse(processId.ToString()));
                }
                catch (Exception)
                {

                    process = null;
                }
                if (process != null)
                {
                    try
                    {
                        var fileName = process.MainModule.FileName;
                        var md5String = GetMd5HashOfAFile(fileName);
                        try
                        {
                            if (_cashing.Contains(md5String))
                            {
                            }
                            else
                            {

                                var result = _scannerForCashing.ScanFile(md5String.ToLower() + "$", 4);
                                if (result)
                                {

                                    var lockedProcesses = FileUtil.WhoIsLocking(fileName).ToList();
                                    foreach (var lockedProcess in lockedProcesses)
                                    {
                                        lockedProcess.Kill();
                                    }
                                    process?.Kill();
                                    File.SetAttributes(fileName, FileAttributes.Normal);
                                    var databaseDirectory = Thread.GetDomain().BaseDirectory + @"Quarantine\";
                                    var filenameWithoutExrtension = Path.GetFileNameWithoutExtension(fileName);
                                    if (File.Exists(databaseDirectory + filenameWithoutExrtension + ".qua"))
                                    {
                                        File.AppendAllText(_workingDirectory + "ServiceTest.txt", databaseDirectory + filenameWithoutExrtension + ".qua" + Environment.NewLine);
                                        File.Delete(databaseDirectory + filenameWithoutExrtension + ".qua");
                                    }
                                    File.Move(fileName, databaseDirectory + filenameWithoutExrtension + ".qua");
                                    File.AppendAllText(_workingDirectory + "ServiceTest.txt", fileName + ": VIRUS REMOVED!" + Environment.NewLine);
                                }
                                else
                                {
                                    _cashing.Add(md5String);
                                    File.AppendAllText(_workingDirectory + "ServiceTest.txt", fileName + ": Scanned" + Environment.NewLine);
                                }
                            }
                            GC.KeepAlive(_cashing);
                            GC.KeepAlive(_scannerForCashing);
                            GC.Collect();
                        }
                        catch (Exception ex)
                        {
                            //
                        }
                    }
                    catch (Exception)
                    {
                        //
                    }
                    finally
                    {
                        GC.KeepAlive(_cashing);
                        GC.KeepAlive(_scannerForCashing);
                        GC.Collect();
                    }
                }
            }, readFileCancelToken);
        }

        public void Scanning()
        {
            List<string> registry = new List<string>();
            _mCancelTokenSource = new CancellationTokenSource();

            // Get a reference to the cancellation token.
            CancellationToken readFileCancelToken = _mCancelTokenSource.Token;
            // Create New Scanner
            foreach (ServiceController sc in ServiceController.GetServices())
            {
                var pathToService = Registry.GetValue(
                    $"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\{sc.ServiceName}", "ImagePath", string.Empty).ToString().Split('-');
                var res = Regex.Replace(pathToService[0], "^\"([^\"]*)\".*$", "$1").Split('/')[0];
                if (!pathToService.Equals(string.Empty))
                {
                    registry.Add(GetMd5HashOfAFile(res));
                }

                registry = registry.Distinct().ToList();
                registry.Sort();
            }
            foreach (var md5 in registry)
            {
                Task.Factory.StartNew(() =>
                {
                    // If cancel has been chosen, throw an exception now before doing anything.
                    readFileCancelToken.ThrowIfCancellationRequested();
                    try
                    {
                        if (md5.Equals(string.Empty)) return;
                        var result = _scannerForCashing.ScanFile(md5 + "$", 4);
                        if (result)
                        {

                            File.AppendAllText(_workingDirectory + "ServiceTest.txt", DateTime.Now + "  -- Service: ScanResult for " + md5 + ": " + "is Infected!!" + Environment.NewLine);
                        }
                    }
                    catch (OperationCanceledException ex)
                    {
                        File.AppendAllText(_workingDirectory + "ServiceTest.txt", "Error: " + ex.StackTrace + Environment.NewLine);
                    }
                    catch (Exception ex)
                    {
                        File.AppendAllText(_workingDirectory + "ServiceTest.txt", "Error: " + ex.StackTrace + Environment.NewLine);
                    }
                    finally
                    {
                        GC.KeepAlive(_cashing);
                        GC.KeepAlive(_scannerForCashing);
                        GC.Collect();
                    }
                }, readFileCancelToken);
            }
        }

        public void FolderWatcher(object sender, DoWorkEventArgs e)
        {

            var startUpFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.Startup);
            FileSystemWatcher watcher = new FileSystemWatcher
            {
                Path = startUpFolderPath,
                NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName
                               | NotifyFilters.DirectoryName
            };
            watcher.Created += this.OnStartupChanged;
            watcher.EnableRaisingEvents = true;

            var startUpFolder1 = Environment.GetFolderPath(Environment.SpecialFolder.CommonStartup);
            FileSystemWatcher watcherAllusers = new FileSystemWatcher
            {
                Path = startUpFolder1,
                NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite
                               | NotifyFilters.FileName | NotifyFilters.DirectoryName
            };
            watcherAllusers.Created += this.OnStartupChanged;
            watcherAllusers.EnableRaisingEvents = true;
        }

        public void OnStartupChanged(object sender, EventArgs e)
        {
            try
            {
                BuildStartup();
            }
            catch (Exception ex)
            {
                File.AppendAllText(_workingDirectory + "ServiceTest.txt", "Error: " + ex.StackTrace + Environment.NewLine);
            }

        }
    }
}
